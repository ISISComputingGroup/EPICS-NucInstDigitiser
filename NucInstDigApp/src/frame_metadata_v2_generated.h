// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAMEMETADATAV2_H_
#define FLATBUFFERS_GENERATED_FRAMEMETADATAV2_H_

#include "flatbuffers/flatbuffers.h"

struct FrameMetadataV2;
struct FrameMetadataV2Builder;

struct GpsTime;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) GpsTime FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t year_;
  int8_t padding0__;
  uint16_t day_;
  uint8_t hour_;
  uint8_t minute_;
  uint8_t second_;
  int8_t padding1__;
  uint16_t millisecond_;
  uint16_t microsecond_;
  uint16_t nanosecond_;

 public:
  GpsTime()
      : year_(0),
        padding0__(0),
        day_(0),
        hour_(0),
        minute_(0),
        second_(0),
        padding1__(0),
        millisecond_(0),
        microsecond_(0),
        nanosecond_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  GpsTime(uint8_t _year, uint16_t _day, uint8_t _hour, uint8_t _minute, uint8_t _second, uint16_t _millisecond, uint16_t _microsecond, uint16_t _nanosecond)
      : year_(flatbuffers::EndianScalar(_year)),
        padding0__(0),
        day_(flatbuffers::EndianScalar(_day)),
        hour_(flatbuffers::EndianScalar(_hour)),
        minute_(flatbuffers::EndianScalar(_minute)),
        second_(flatbuffers::EndianScalar(_second)),
        padding1__(0),
        millisecond_(flatbuffers::EndianScalar(_millisecond)),
        microsecond_(flatbuffers::EndianScalar(_microsecond)),
        nanosecond_(flatbuffers::EndianScalar(_nanosecond)) {
    (void)padding0__;
    (void)padding1__;
  }
  uint8_t year() const {
    return flatbuffers::EndianScalar(year_);
  }
  uint16_t day() const {
    return flatbuffers::EndianScalar(day_);
  }
  uint8_t hour() const {
    return flatbuffers::EndianScalar(hour_);
  }
  uint8_t minute() const {
    return flatbuffers::EndianScalar(minute_);
  }
  uint8_t second() const {
    return flatbuffers::EndianScalar(second_);
  }
  uint16_t millisecond() const {
    return flatbuffers::EndianScalar(millisecond_);
  }
  uint16_t microsecond() const {
    return flatbuffers::EndianScalar(microsecond_);
  }
  uint16_t nanosecond() const {
    return flatbuffers::EndianScalar(nanosecond_);
  }
};
FLATBUFFERS_STRUCT_END(GpsTime, 14);

struct FrameMetadataV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameMetadataV2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_PERIOD_NUMBER = 6,
    VT_PROTONS_PER_PULSE = 8,
    VT_RUNNING = 10,
    VT_FRAME_NUMBER = 12,
    VT_VETO_FLAGS = 14
  };
  const GpsTime *timestamp() const {
    return GetStruct<const GpsTime *>(VT_TIMESTAMP);
  }
  uint64_t period_number() const {
    return GetField<uint64_t>(VT_PERIOD_NUMBER, 0);
  }
  uint8_t protons_per_pulse() const {
    return GetField<uint8_t>(VT_PROTONS_PER_PULSE, 0);
  }
  bool running() const {
    return GetField<uint8_t>(VT_RUNNING, 0) != 0;
  }
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  uint16_t veto_flags() const {
    return GetField<uint16_t>(VT_VETO_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<GpsTime>(verifier, VT_TIMESTAMP, 2) &&
           VerifyField<uint64_t>(verifier, VT_PERIOD_NUMBER, 8) &&
           VerifyField<uint8_t>(verifier, VT_PROTONS_PER_PULSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RUNNING, 1) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER, 4) &&
           VerifyField<uint16_t>(verifier, VT_VETO_FLAGS, 2) &&
           verifier.EndTable();
  }
};

struct FrameMetadataV2Builder {
  typedef FrameMetadataV2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(const GpsTime *timestamp) {
    fbb_.AddStruct(FrameMetadataV2::VT_TIMESTAMP, timestamp);
  }
  void add_period_number(uint64_t period_number) {
    fbb_.AddElement<uint64_t>(FrameMetadataV2::VT_PERIOD_NUMBER, period_number, 0);
  }
  void add_protons_per_pulse(uint8_t protons_per_pulse) {
    fbb_.AddElement<uint8_t>(FrameMetadataV2::VT_PROTONS_PER_PULSE, protons_per_pulse, 0);
  }
  void add_running(bool running) {
    fbb_.AddElement<uint8_t>(FrameMetadataV2::VT_RUNNING, static_cast<uint8_t>(running), 0);
  }
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(FrameMetadataV2::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_veto_flags(uint16_t veto_flags) {
    fbb_.AddElement<uint16_t>(FrameMetadataV2::VT_VETO_FLAGS, veto_flags, 0);
  }
  explicit FrameMetadataV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FrameMetadataV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameMetadataV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameMetadataV2> CreateFrameMetadataV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    const GpsTime *timestamp = nullptr,
    uint64_t period_number = 0,
    uint8_t protons_per_pulse = 0,
    bool running = false,
    uint32_t frame_number = 0,
    uint16_t veto_flags = 0) {
  FrameMetadataV2Builder builder_(_fbb);
  builder_.add_period_number(period_number);
  builder_.add_frame_number(frame_number);
  builder_.add_timestamp(timestamp);
  builder_.add_veto_flags(veto_flags);
  builder_.add_running(running);
  builder_.add_protons_per_pulse(protons_per_pulse);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_FRAMEMETADATAV2_H_
